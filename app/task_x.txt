  task_a.c (task_a.h) 
   Blocking Code
   Primero, en la función task_a_init, la tarea se inicializa: imprime por consola un mensaje indicando que comenzó a ejecutarse y pone el contador global g_task_a_cnt en cero.
   Después, en la función task_a_update, el comportamiento de la tarea depende del valor de la constante TEST_X:
   - Si TEST_X vale TEST_0, cada vez que la tarea se ejecuta incrementa en uno el contador global y luego hace un bucle vacío desde 0 hasta 1000.
   - Si TEST_X vale TEST_1, en lugar del bucle, la tarea se queda bloqueada esperando 20 milisegundos mediante la función HAL_Delay.

  task_b.c (task_b.h)
   Non-Blocking Code
El código task_b.c implementa la Tarea B de una aplicación embebida.
Incluye las bibliotecas del proyecto:
main.h
logger.h
dwt.h
board.h
app.h
Define macros como los que sigue:
G_TASK_B_CNT_INI → valor inicial del contador global.
TASK_B_CNT_INI y TASK_B_CNT_MAX → definen el inicio y el límite del contador local.
TASK_B_DEL_INI y TASK_B_DEL_MAX → definen el inicio y el intervalo máximo del temporizador (en milisegundos).
Dispone de los siguientes métodos.
	1	task_b_init(void *parameters)
		Inicializa la tarea B.
		Imprime en el log que la tarea está corriendo.
		Reinicia el contador global g_task_b_cnt y lo muestra por consola/log.
	2	task_b_update(void *parameters)
		Actualiza la lógica de la tarea según la macro de compilación TEST_X:
		TEST_0: contador cíclico (de 0 a TASK_B_CNT_MAX).
		TEST_1: delay no bloqueante controlado por ticks del sistema.
		TEST_2: espacio reservado para código futuro
...

  task_c.c (task_c.h)
   Update by Time Code
   Primero, en la función task_c_init, la tarea se inicializa: imprime por consola un mensaje indicando que comenzó a ejecutarse y pone el contador global g_task_c_cnt en cero.
   Después, en la función task_c_update, el comportamiento de la tarea depende del valor de la variable g_task_c_tick_cnt:
   - Si G_TASK_C_TICK_CNT_INI < g_task_c_tick_cnt, decrementa en 1 g_task_c_tick_cnt y habilita el ingreso al while.
     Dentro del while(), mientras que incrementa en 1 g_task_c_cnt y vuelve a consultar si G_TASK_C_TICK_CNT_INI < g_task_c_tick_cnt. Si lo es, decrementa en 1 g_task_c_tick_cnt y sino modifica el valor de b_time_update_required a FALSE para que en la próxima vuelta salga del while. De esta forma, se incrementará g_task_c_cnt tantas tantas veces como mayor a G_TASK_C_TICK_CNT_INI sea g_task_c_tick_cnt.  
   El valor de g_task_c_tick_cnt se incrementa desde la función HAL_SYSTICK_Callback() declarada en app.c. Es por ello que la variable g_task_c_tick_cnt está declarada como volatile en forma global.
   